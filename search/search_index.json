{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> The fast, most optimal, and correct HTML &amp; XML parsing library </p> <p> </p> <p>MarkupEver is a modern, fast (high-performance), XML &amp; HTML languages parsing library written in Rust.</p> <ul> <li> <p> - Fast</p> <p>Very high performance and fast (thanks to html5ever and selectors).</p> <p>Benchmarks </p> </li> <li> <p> - Easy To Use</p> <p>Designed to be easy to use and learn. Completion everywhere.</p> <p>Examples </p> </li> <li> <p> - Low Memory Usage</p> <p>It boasts efficient memory usage, thanks to Rust's memory allocator, ensuring no memory leaks. </p> <p>Memory Usage </p> </li> <li> <p> - Your CSS Knowledge</p> <p>Leverage your CSS knowledge to select elements from HTML or XML documents effortlessly.</p> <p>Querying </p> </li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>You can install MarkupEver using pip:</p> <pre><code>$ pip3 install markupever\n</code></pre> <p>Use Virtual Environments</p> <p>It's recommended to use virtual environments for installing and managing libraries in Python.</p> Linux (venv)Linux (virtualenv)Windows (venv)Windows (virtualenv) <pre><code>$ python3 -m venv venv\n$ source venv/bin/activate\n</code></pre> <pre><code>$ virtualenv venv\n$ source venv/bin/activate\n</code></pre> <pre><code>$ python3 -m venv venv\n$ venv\\Scripts\\activate\n</code></pre> <pre><code>$ virtualenv venv\n$ venv\\Scripts\\activate\n</code></pre>"},{"location":"#examples","title":"Examples","text":"<p>More Examples</p> <p>There are some good and basic examples to how to use <code>markupever</code> library. Even if you need more examples, see this page: More Examples </p>"},{"location":"#parsing-scraping","title":"Parsing &amp; Scraping","text":"<p>Parsing a HTML content and selecting elements:</p> <p>Imagine this <code>index.html</code> file:</p> index.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Example Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1 id=\"title\"&gt;Welcome to My Page&lt;/h1&gt;\n    &lt;p&gt;This page has a link and an image.&lt;/p&gt;\n    &lt;a href=\"https://www.example.com\"&gt;Visit Example.com&lt;/a&gt;\n    &lt;br&gt;\n    &lt;img src=\"https://www.example.com/image.jpg\" alt=\"My Image\"&gt;\n    &lt;a href=\"https://www.google.com\"&gt;Visit Google&lt;/a&gt;\n    &lt;a&gt;No Link&lt;/a&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>We want to extract the <code>href</code> attributes from it, and we have three ways to achieve this:</p> Parse ContentRead From FileUse Parser Directly <p>You can parse HTML/XML content with <code>parse()</code> function.</p> main.py<pre><code>import markupever\nwith open(\"index.html\", \"rb\") as fd: # (2)!\n    dom = markupever.parse(fd.read(), markupever.HtmlOptions()) # (1)!\n\nfor element in dom.select(\"a[href]\"):\n    print(element.attrs[\"href\"])\n</code></pre> <ol> <li> <p>Use <code>HtmlOptions()</code> for HTML documents and <code>XmlOptions()</code> for XML documents. If used incorrectly, don't worry\u2014it won't disrupt the process. These options specify namespaces and other differences between XML and HTML, while also providing distinct features for each type.</p> </li> <li> <p>It's recommended to open files with <code>\"rb\"</code> mode, but not required; you can use <code>\"r\"</code> mode also.</p> </li> </ol> <p>You can parse HTML/XML content from files with <code>.parse_file()</code> function.</p> main.py<pre><code>import markupever\ndom = markupever.parse_file(\"index.html\", markupever.HtmlOptions()) # (1)!\n\nfor element in dom.select(\"a[href]\"):\n    print(element.attrs[\"href\"])\n</code></pre> <ol> <li>Use <code>HtmlOptions()</code> for HTML documents and <code>XmlOptions()</code> for XML documents. If used incorrectly, don't worry\u2014it won't disrupt the process. These options specify namespaces and other differences between XML and HTML, while also providing distinct features for each type.</li> </ol> <p>The .parse() and .parse_file() functions are shorthand for using the .Parser class. However, you can also use the class directly. It's designed to allow you to stream input using the .process() method, so you don't have to worry about the memory usage of large inputs.</p> main.py<pre><code>import markupever\nparser = markupever.Parser(markupever.HtmlOptions()) # (1)!\n\nwith open(\"index.html\", \"rb\") as fd: # (2)!\n    for line in fd: # Read line by line (3)\n        parser.process(line)\n\nparser.finish()\ndom = parser.into_dom()\n\nfor element in dom.select(\"a[href]\"):\n    print(element.attrs[\"href\"])\n</code></pre> <ol> <li> <p>Use <code>HtmlOptions()</code> for HTML documents and <code>XmlOptions()</code> for XML documents. If used incorrectly, don't worry\u2014it won't disrupt the process. These options specify namespaces and other differences between XML and HTML, while also providing distinct features for each type.</p> </li> <li> <p>It's recommended to open files with <code>\"rb\"</code> mode, but not required; you can use <code>\"r\"</code> mode also.</p> </li> <li> <p>You can read the file all at once and pass it to the <code>process</code> function. We have broken the file into lines here to show you the <code>Parser</code>'s abilities.</p> </li> </ol> <p>Then run <code>main.py</code> to see result:</p> <pre><code>$ python3 main.py\nhttps://www.example.com\nhttps://www.google.com\n</code></pre>"},{"location":"#creating-documents","title":"Creating Documents","text":"<p>Also there's a structure called <code>TreeDom</code> (1). You can directly work with it and generate documents (such as HTML and XML) very easy.</p> <ol> <li>A tree structure which specialy designed for HTML and XML documents. Uses Rust's <code>Vec</code> type in backend.     The memory consumed by the <code>TreeDom</code> is dynamic and depends on the number of tokens stored in the tree.     The allocated memory is never reduced and is only released when it is dropped.</li> </ol> <pre><code>from markupever import dom\n\ndom = dom.TreeDom()\nroot: dom.Document = dom.root()\n\nroot.create_doctype(\"html\")\n\nhtml = root.create_element(\"html\", {\"lang\": \"en\"})\nbody = html.create_element(\"body\")\nbody.create_text(\"Hello Everyone ...\")\n\nprint(root.serialize())\n# &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;body&gt;Hello Everyone ...&lt;/body&gt;&lt;/html&gt;\n</code></pre>"},{"location":"#performance","title":"Performance","text":"<p>This library is designed with a strong focus on performance and speed. It's written in Rust and avoids the use of unsafe code blocks.</p> <p>I have compared MarkupEver with BeautifulSoup and Parsel (which directly uses <code>lxml</code>):</p>"},{"location":"#benchmarks","title":"Benchmarks","text":"<p>System</p> <p>The system on which the benchmarks are done: Manjaro Linux x86_64, 8G, Intel i3-1115G4</p> Parsing Min Max Avg markupever 4907\u00b5s 4966\u00b5s 4927\u00b5s markupever (exact_errors) 8920\u00b5s 9172\u00b5s 8971\u00b5s beautifulsoup4 (html.parser) 35283\u00b5s 36460\u00b5s 35828\u00b5s beautifulsoup4 (lxml) 22576\u00b5s 23092\u00b5s 22809\u00b5s parsel 3937\u00b5s 4147\u00b5s 4072\u00b5s html5lib (etree) 63214\u00b5s 63844\u00b5s 63489\u00b5s html5lib (dom) 88111\u00b5s 90721\u00b5s 89580\u00b5s Selecting (CSS) Min Max Avg markupever 308\u00b5s 314\u00b5s 310\u00b5s beautifulsoup4 2936\u00b5s 3074\u00b5s 2995\u00b5s parsel 159\u00b5s 165\u00b5s 161\u00b5s html5lib N/A N/A N/A Serializing Min Max Avg markupever 1932\u00b5s 1973\u00b5s 1952\u00b5s beautifulsoup4 14705\u00b5s 15021\u00b5s 14900\u00b5s parsel 1264\u00b5s 1290\u00b5s 1276\u00b5s html5lib 17557\u00b5s 18097\u00b5s 17831\u00b5s <p>Summary</p> <p>The Parsel is the fastest library (Actually <code>lxml</code> is) and is specially designed for scraping, but it offers less control over the document. The html5lib is the slowest library and does not support selecting elements by CSS Selectors. The BeautifulSoup library's speed is also slow which provides full control over the document.</p> <p>The MarkupEver sites between BeautifulSoup and Parsel library. It is extremely fast - close to Parsel, and offers full control over the document.</p>"},{"location":"#memory-usage","title":"Memory Usage","text":"<p>As you know, this library is written in Rust and uses the Rust allocator. Like other libraries written in C and other low-level languages, it uses very low memory, so you don't have to worry about memory usage. Manage huge documents with ease...</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MPL-2.0 license.</p>"},{"location":"more-examples/","title":"More Examples","text":"<p>There's a collection of examples for markupever library.</p> <p>Warning</p> <p>This documentation is incomplete. Documenting everything take a while.</p>"},{"location":"more-examples/#using-markupever-alongside-http-clients","title":"Using markupever alongside HTTP clients","text":"<p>How to use markupever alongside HTTP clients such as <code>httpx</code>, <code>requests</code> and <code>aiohttp</code>.</p> httpx (traditional)httpx (recommended)requestsaiohttp <pre><code>with httpx.Client() as client:\n    response = client.get(\"https://www.example.com/\")\n    dom = markupever.parse(response.content, markupever.HtmlOptions())\n</code></pre> <pre><code>with httpx.Client() as client:\n    with client.stream(\n        \"GET\",\n        \"https://www.example.com/\",\n    ) as stream:\n        parser = markupever.Parser(markupever.HtmlOptions())\n\n        for content in stream.iter_bytes():\n            parser.process(content)\n\n        dom = parser.finish().into_dom()\n</code></pre> <pre><code>response = requests.get(\"https://www.example.com/\")\ndom = markupever.parse(response.content, markupever.HtmlOptions())\n</code></pre> <pre><code>async with aiohttp.ClientSession() as session:\n    async with session.get('https://www.google.com/') as resp:\n        dom = markupever.parse(await resp.read(), markupever.HtmlOptions())\n</code></pre>"},{"location":"parser/","title":"Getting started","text":"<p>The first thing expected from such this libraries is the ability to read HTML, XML, and similar documents.</p> <p>The MarkupEver is designed specially for reading, parsing, and repairing HTML and XML documents (also can parse similar documents).</p> <p>In MarkupEver we have some functions (1) and a class (2) for doing that.</p> <ol> <li><code>.parse()</code> and <code>.parse_file()</code> functions</li> <li><code>Parser</code> class</li> </ol> <p>Additionaly, they have special features that distinguish this library from others:</p> <ul> <li>You don't worry about huge memory usage.</li> <li>You can read and parse documents part by part (such as files, streams, ...).</li> <li>You can specify some options for parsing which can help you (with <code>HtmlOptions()</code> and <code>XmlOptions()</code> classes).</li> <li>You can repair invalid documents automatically.</li> </ul>"},{"location":"parser/#parsing-html","title":"Parsing Html","text":"<p>Imagine this <code>index.html</code> file:</p> index.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Incomplete Html&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;ul&gt;\n        &lt;li&gt;&lt;a href=\"https://www.example.com\"&gt;Example Website&lt;/a&gt;&lt;/li&gt;\n        &lt;li&gt;&lt;a href=\"https://www.wikipedia.org\"&gt;Wikipedia&lt;/a&gt;&lt;/li&gt;\n        &lt;li&gt;&lt;a href=\"https://www.bbc.com\"&gt;BBC&lt;/a&gt;&lt;/li&gt;\n        &lt;li&gt;&lt;a href=\"https://www.microsoft.com\"&gt;Microsoft&lt;/a&gt;&lt;/li&gt;\n    &lt;/ul&gt;\n</code></pre> <p>We can use <code>.parse()</code> and <code>.parse_file()</code> functions to parse documents.</p> <p>The Difference</p> <p>the <code>.parse_file()</code> function gets a <code>BinaryIO</code>, a <code>TextIO</code> or a file path and parses it chunk by chunk; but <code>.parse()</code> function gets all document content at once. By this way, using <code>.parse_file()</code> is very better than <code>.parse()</code>.</p> <p>Let's use them:</p> .parse() function.parse_file() function <pre><code>import markupever\n\nwith open(\"index.html\", \"rb\") as fd:\n    dom = markupever.parse(fd.read(), markupever.HtmlOptions())\n</code></pre> <pre><code>import markupever\n\ndom = markupever.parse_file(\"index.html\", markupever.HtmlOptions())\n</code></pre> <p>HtmlOptions</p> <p>See HtmlOptions parameters.</p> <p>That's it, we parsed <code>index.html</code> file and now have a <code>TreeDom</code> class. We can navigate that:</p> <pre><code>root = dom.root() # Get root node\nroot\n# Document\n\ntitle = root.select_one(\"title\") # Accepts CSS selectors\ntitle.name\n# QualName(local=\"title\", ns=\"http://www.w3.org/1999/xhtml\", prefix=None)\n\ntitle.serialize()\n# '&lt;title&gt;Incomplete Html&lt;/title&gt;'\n\ntitle.text()\n# 'Incomplete Html'\n\ntitle.parent.name\n# QualName(local=\"head\", ns=\"http://www.w3.org/1999/xhtml\", prefix=None)\n\nul = root.select_one(\"ul\")\nul.serialize()\n# &lt;ul&gt;\n#     &lt;li&gt;&lt;a href=\"https://www.example.com\"&gt;Example Website&lt;/a&gt;&lt;/li&gt;\n#     &lt;li&gt;&lt;a href=\"https://www.wikipedia.org\"&gt;Wikipedia&lt;/a&gt;&lt;/li&gt;\n#     &lt;li&gt;&lt;a href=\"https://www.bbc.com\"&gt;BBC&lt;/a&gt;&lt;/li&gt;\n#     &lt;li&gt;&lt;a href=\"https://www.microsoft.com\"&gt;Microsoft&lt;/a&gt;&lt;/li&gt;\n# &lt;/ul&gt;\n</code></pre> <p>Common task</p> <p>One common tasks is extracting all links from a page: <pre><code>for tag in root.select(\"a[href^='https://']\"):\n    print(tag.attrs[\"href\"])\n\n# https://www.example.com\n# https://www.wikipedia.org\n# https://www.bbc.com\n# https://www.microsoft.com\n</code></pre></p> <p>Additionaly, if you serialize the parsed DOM you'll see that the incomplete HTML is repaired: <pre><code>root.serialize()\n# &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;\n#     &lt;title&gt;Incomplete Html&lt;/title&gt;\n# &lt;/head&gt;\n# &lt;body&gt;\n#     &lt;ul&gt;\n#         &lt;li&gt;&lt;a href=\"https://www.example.com\"&gt;Example Website&lt;/a&gt;&lt;/li&gt;\n#         &lt;li&gt;&lt;a href=\"https://www.wikipedia.org\"&gt;Wikipedia&lt;/a&gt;&lt;/li&gt;\n#         &lt;li&gt;&lt;a href=\"https://www.bbc.com\"&gt;BBC&lt;/a&gt;&lt;/li&gt;\n#         &lt;li&gt;&lt;a href=\"https://www.microsoft.com\"&gt;Microsoft&lt;/a&gt;&lt;/li&gt;\n#     &lt;/ul&gt;\n# &lt;/body&gt;&lt;/html&gt;\n</code></pre></p>"},{"location":"parser/#parsing-xml","title":"Parsing XML","text":"<p>Imagine this <code>file.xml</code> file:</p> file.xml<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;bookstore xmlns:bk=\"http://www.example.com/books\" xmlns:mag=\"http://www.example.com/magazines\"&gt;\n  &lt;bk:book&gt;\n    &lt;bk:title&gt;Programming for Beginners&lt;/bk:title&gt;\n    &lt;bk:author&gt;Jane Doe&lt;/bk:author&gt;\n    &lt;bk:year&gt;2021&lt;/bk:year&gt;\n  &lt;/bk:book&gt;\n  &lt;mag:magazine&gt;\n    &lt;mag:title&gt;Technology Monthly&lt;/mag:title&gt;\n    &lt;mag:publisher&gt;Tech Publishers&lt;/mag:publisher&gt;\n    &lt;mag:month&gt;March&lt;/mag:month&gt;\n  &lt;/mag:magazine&gt;\n&lt;/bookstore&gt;\n</code></pre> <p>Let's use <code>.parse()</code> / <code>.parse_file()</code> function to parse it (we explained them earlier):</p> .parse() function.parse_file() function <pre><code>import markupever\n\nwith open(\"file.xml\", \"rb\") as fd:\n    dom = markupever.parse(fd.read(), markupever.XmlOptions())\n</code></pre> <pre><code>import markupever\n\ndom = markupever.parse_file(\"file.xml\", markupever.XmlOptions())\n</code></pre> <p>XmlOptions</p> <p>See XmlOptions parameters.</p> <p>That's it, we parsed <code>file.xml</code> file and now have a <code>TreeDom</code> class. We can navigate that like what we did in this section:</p> <pre><code>root = dom.root() # Get root node\nroot\n# Document\n\nroot.select_one(\"bookstore\")\n# Element(name=QualName(local=\"bookstore\"), attrs=[], template=false, mathml_annotation_xml_integration_point=false)\n\nfor i in root.select(\"mag|*\"): # get all elements which has namespace 'mag'\n    print(i)\n# Element(name=QualName(local=\"magazine\", ns=\"http://www.example.com/magazines\", prefix=Some(\"mag\")), attrs=[], template=false, mathml_annotation_xml_integration_point=false)\n# Element(name=QualName(local=\"title\", ns=\"http://www.example.com/magazines\", prefix=Some(\"mag\")), attrs=[], template=false, mathml_annotation_xml_integration_point=false)\n# Element(name=QualName(local=\"publisher\", ns=\"http://www.example.com/magazines\", prefix=Some(\"mag\")), attrs=[], template=false, mathml_annotation_xml_integration_point=false)\n# Element(name=QualName(local=\"month\", ns=\"http://www.example.com/magazines\", prefix=Some(\"mag\")), attrs=[], template=false, mathml_annotation_xml_integration_point=false)\n\nbook = root.select_one(\"book\")\nbook.serialize()\n# &lt;bk:book xmlns:bk=\"http://www.example.com/books\"&gt;\n#   &lt;bk:title&gt;Programming for Beginners&lt;/bk:title&gt;\n#   &lt;bk:author&gt;Jane Doe&lt;/bk:author&gt;\n#   &lt;bk:year&gt;2021&lt;/bk:year&gt;\n# &lt;/bk:book&gt;\n</code></pre>"},{"location":"parser/#using-parser","title":"Using Parser","text":"<p>The functions <code>.parse()</code> and <code>.parse_file()</code>, which you became familiar with earlier, internally use <code>Parser</code> class which actually does the parsing. In this part we want to learn the <code>Parser</code> class.</p> <p>The <code>Parser</code> class is an HTML/XML parser, ready to receive Unicode input. It is very easy to use and allows you to stream input using the <code>.process()</code> method. This way, you don't have to worry about the memory usage of large inputs.</p> <p>As we said about options parameter in <code>.parse()</code> and <code>.parse_file()</code>, if your input is an HTML document, pass a <code>HtmlOptions()</code>; if your input is an XML document, pass <code>XmlOptions()</code></p> <p>To start, create an instance of the <code>Parser</code> class. Then, use the <code>Parser.process()</code> method to send content for parsing. You can call this method as many times as you want (it's thread-safe). When your inputs are finished, call the <code>Parser.finish()</code> method to mark the parser as finished.</p> <pre><code>import markupever\n\n# Create Parser\nparser = markupever.Parser(options=markupever.HtmlOptions())\n\n# Process contents\nparser.process(\"... content 1 ...\")\nparser.process(\"... content 2 ...\")\nparser.process(\"... content 3 ...\")\n\n# Mark as finished\nparser.finish()\n</code></pre> <p>That's it! Your HTML document parsing is now finished and complete. The Parser class has several methods and attributes to inform you about the parsed content, such as the <code>lineno</code> property, <code>quirks_mode</code> property, and <code>errors()</code> method. You can see examples:</p> <code>lineno</code> property<code>quirks_mode</code> property<code>errors()</code> method <p>Returns the line count of the parsed content (always is <code>1</code> for XML).</p> <pre><code>print(parser.lineno)\n# 56\n</code></pre> <p>Returns the quirks mode (always is QUIRKS_MODE_OFF for XML).</p> <p>See quirks mode on wikipedia for more information.</p> <pre><code>print(parser.quirks_mode)\n# 2\n</code></pre> <p>Returns the errors which are detected while parsing.</p> <pre><code>print(parser.errors())\n# ['Unexpected token']\n</code></pre> <p>You can use these properties and methods before calling the <code>Parser.into_dom()</code> method. The <code>Parser.into_dom()</code> method converts the parser into a <code>TreeDom</code> and releases its allocated memory.</p> <pre><code>import markupever\nparser = markupever.Parser(options=markupever.HtmlOptions())\nparser.process(\"... content 1 ...\")\nparser.process(\"... content 2 ...\")\nparser.process(\"... content 3 ...\")\nparser.finish()\n\n# Use `.errors()`, `.lineno`, or `.quirks_mode` if you want\n\ndom = parser.into_dom()\n</code></pre>"},{"location":"parser/#more-about-options","title":"More about options","text":"<p>We have two structures for parsing options: <code>HtmlOptions()</code> and <code>XmlOptions()</code>.</p> <p>Use <code>HtmlOptions()</code> for HTML documents and <code>XmlOptions()</code> for XML documents. If used incorrectly, don't worry \u2014 it won't disrupt the process. These options specify namespaces and other differences between XML and HTML, while also providing distinct features for each type.</p>"},{"location":"parser/#htmloptions-parameters","title":"HtmlOptions parameters","text":"<p>Let's see what parameters we have:</p> <ul> <li><code>full_document</code> - Specifies that is this a complete document? default: True.</li> </ul> TrueFalse <pre><code>import markupever\n\ndom = markupever.parse(\"&lt;p&gt;A Text&lt;/p&gt;\", markupever.HtmlOptions(full_document=True))\ndom.serialize()\n# &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;A Text&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n</code></pre> <pre><code>import markupever\n\ndom = markupever.parse(\"&lt;p&gt;A Text&lt;/p&gt;\", markupever.HtmlOptions(full_document=False))\ndom.serialize()\n# &lt;html&gt;&lt;p&gt;A Text&lt;/p&gt;&lt;/html&gt;\n</code></pre> <ul> <li><code>exact_errors</code> - Report all parse errors described in the spec, at some performance penalty? default: False.</li> </ul> TrueFalse <pre><code>import markupever\np = markupever.Parser(markupever.HtmlOptions(exact_errors=True))\np.process(\"&lt;p&gt;A Text&lt;/p&gt;\")\np.finish()\np.errors()\n# [\"Unexpected token TagToken(Tag { kind: StartTag, name: Atom(\\\\'p\\\\' type=inline), self_closing: false, attrs: [] }) in insertion mode Initial\"]\n</code></pre> <pre><code>import markupever\np = markupever.Parser(markupever.HtmlOptions(exact_errors=False))\np.process(\"&lt;p&gt;A Text&lt;/p&gt;\")\np.finish()\np.errors()\n# [\"Unexpected token\"]\n</code></pre> <ul> <li> <p><code>discard_bom</code> - Discard a <code>U+FEFF BYTE ORDER MARK</code> if we see one at the beginning of the stream? default: False.</p> </li> <li> <p><code>profile</code> - Keep a record of how long we spent in each state? Printed when <code>finish()</code> is called. default: False.</p> </li> </ul> TrueFalse <pre><code>import markupever\n\nmarkupever.parse(\"&lt;p&gt;A Text&lt;/p&gt;\", markupever.HtmlOptions(profile=True))\n#\n# Tokenizer profile, in nanoseconds\n#\n#    93331         total in token sink\n#\n#    46121         total in tokenizer\n#    17651  38.3%  Data\n#    13640  29.6%  TagName\n#    11768  25.5%  TagOpen\n#     3062   6.6%  EndTagOpen\n</code></pre> <pre><code>import markupever\n\nmarkupever.parse(\"&lt;p&gt;A Text&lt;/p&gt;\", markupever.HtmlOptions(profile=False))\n</code></pre> <ul> <li> <p><code>iframe_srcdoc</code> - Is this an <code>iframe srcdoc</code> document? default: False.</p> </li> <li> <p><code>drop_doctype</code> - Should we drop the DOCTYPE (if any) from the tree? default: False.</p> </li> </ul> TrueFalse <pre><code>import markupever\n\ndom = markupever.parse(\"&lt;!DOCTYPE html&gt;&lt;p&gt;A Text&lt;/p&gt;\", markupever.HtmlOptions(drop_doctype=True))\ndom.serialize()\n# &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;A Text&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n</code></pre> <pre><code>import markupever\n\ndom = markupever.parse(\"&lt;!DOCTYPE html&gt;&lt;p&gt;A Text&lt;/p&gt;\", markupever.HtmlOptions(drop_doctype=False))\ndom.serialize()\n# &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;A Text&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n</code></pre> <ul> <li><code>quirks_mode</code> - Initial TreeBuilder quirks mode. default: <code>markupever.QUIRKS_MODE_OFF</code>.</li> </ul>"},{"location":"parser/#xmloptions-parameters","title":"XmlOptions parameters","text":"<p>Let's see what parameters we have:</p> <ul> <li><code>exact_errors</code> - Report all parse errors described in the spec, at some performance penalty? default: False.</li> </ul> TrueFalse <pre><code>import markupever\np = markupever.Parser(markupever.XmlOptions(exact_errors=True))\np.process(\"&lt;p&gt;A Text&lt;/p&gt;\")\np.finish()\np.errors()\n# [\"Unexpected token TagToken(Tag { kind: StartTag, name: Atom(\\\\'p\\\\' type=inline), self_closing: false, attrs: [] }) in insertion mode Initial\"]\n</code></pre> <pre><code>import markupever\np = markupever.Parser(markupever.XmlOptions(exact_errors=False))\np.process(\"&lt;p&gt;A Text&lt;/p&gt;\")\np.finish()\np.errors()\n# [\"Unexpected token\"]\n</code></pre> <ul> <li> <p><code>discard_bom</code> - Discard a <code>U+FEFF BYTE ORDER MARK</code> if we see one at the beginning of the stream? default: False.</p> </li> <li> <p><code>profile</code> - Keep a record of how long we spent in each state? Printed when <code>finish()</code> is called. default: False.</p> </li> </ul> TrueFalse <pre><code>import markupever\n\nmarkupever.parse(\"&lt;p&gt;A Text&lt;/p&gt;\", markupever.XmlOptions(profile=True))\n#\n# Tokenizer profile, in nanoseconds\n#\n#    93331         total in token sink\n#\n#    46121         total in tokenizer\n#    17651  38.3%  Data\n#    13640  29.6%  TagName\n#    11768  25.5%  TagOpen\n#     3062   6.6%  EndTagOpen\n</code></pre> <pre><code>import markupever\n\nmarkupever.parse(\"&lt;p&gt;A Text&lt;/p&gt;\", markupever.XmlOptions(profile=False))\n</code></pre>"},{"location":"querying/","title":"CSS Selectors","text":"<p>The MarkupEver supports all the syntax that soupsieve does, except for some pseudo-elements (I prefer not to document all these syntaxes again).</p>"},{"location":"querying/#some-examples","title":"Some Examples","text":"<p>To start, imagine this document:</p> <pre><code>import markupever\n\ntree = markupever.parse(\n    \"\"\"\n    &lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;Example Document&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;p class=\"par-one\"&gt;CSS Selector Example&lt;/p&gt;\n        &lt;p class=\"par-two\"&gt;I wish you a good day&lt;/p&gt;\n        &lt;p class=\"end-par\"&gt;I wish you a good day&lt;/p&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\",\n    markupever.HtmlOptions()\n)\n</code></pre> <p>Let's see some examples:</p> <pre><code>print(tree.select_one(\"head &gt; title\").text())\n# Example Document\n\nfor element in tree.select(\"[class^=par-]\"):\n    print(element)\n# Element(name=QualName(local=\"p\", ns=\"http://www.w3.org/1999/xhtml\", prefix=None), attrs=[(QualName(local=\"class\"), \"par-one\")], template=false, integration_point=false)\n# Element(name=QualName(local=\"p\", ns=\"http://www.w3.org/1999/xhtml\", prefix=None), attrs=[(QualName(local=\"class\"), \"par-two\")], template=false, integration_point=false)\n\nprint(tree.select_one(\"p\", offset=3))\n# Element(name=QualName(local=\"p\", ns=\"http://www.w3.org/1999/xhtml\", prefix=None), attrs=[(QualName(local=\"class\"), \"end-par\")], template=false, integration_point=false)\n\nfor element in tree.select(\"[class*=par]\", offset=3, limit=1):\n    print(element)\n# Element(name=QualName(local=\"p\", ns=\"http://www.w3.org/1999/xhtml\", prefix=None), attrs=[(QualName(local=\"class\"), \"end-par\")], template=false, integration_point=false)\n</code></pre>"},{"location":"treedom/","title":"DOM Usage","text":"<ul> <li> <p> - Build A Document</p> <p>In MarkupEver, we use a class named <code>TreeDom</code> (1) as a tree structure. This class allows you to ...</p> <p>More </p> </li> <li> <p> - Navigating the tree</p> <p>The most important thing in trees is navigating between elements and how to interact with them ...</p> <p>More </p> </li> </ul>"},{"location":"treedom/#navigating-the-tree","title":"Navigating the tree","text":"<p>The most important thing in trees is navigating between elements and how to interact with them \u2014 specially after parsing a document.</p> <p>Each node may contain text and other nodes. MarkupEver provides numerous properties, methods, and iterators to help you work with and navigate between them.</p> <p>Note</p> <p>We won't discuss .select and .select_one here. They are introduced in Parsing and Querying.</p> <p>Imagine this to start:</p> <pre><code>import markupever\n\ndom: markupever.dom.TreeDom = markupever.parse(\n    \"\"\"\n    &lt;note&gt;&lt;to&gt;Tove&lt;/to&gt;\n        &lt;from&gt;Jani&lt;/from&gt;\n        &lt;heading&gt;Reminder&lt;/heading&gt;\n        &lt;body&gt;Don't forget me this weekend!&lt;/body&gt;&lt;/note&gt;\n    \"\"\",\n    markupever.XmlOptions()\n)\nroot = dom.root()\n\n# Document\n# \u2514\u2500\u2500 Element(name=QualName(local=\"note\"), attrs=[], template=false, integration_point=false)\n#     \u251c\u2500\u2500 Element(name=QualName(local=\"to\"), attrs=[], template=false, integration_point=false)\n#     \u2502   \u2514\u2500\u2500 Text(content=\"Tove\")\n#     \u251c\u2500\u2500 Text(content=\"\\n        \")\n#     \u251c\u2500\u2500 Element(name=QualName(local=\"from\"), attrs=[], template=false, integration_point=false)\n#     \u2502   \u2514\u2500\u2500 Text(content=\"Jani\")\n#     \u251c\u2500\u2500 Text(content=\"\\n        \")\n#     \u251c\u2500\u2500 Element(name=QualName(local=\"heading\"), attrs=[], template=false, integration_point=false)\n#     \u2502   \u2514\u2500\u2500 Text(content=\"Reminder\")\n#     \u251c\u2500\u2500 Text(content=\"\\n        \")\n#     \u2514\u2500\u2500 Element(name=QualName(local=\"body\"), attrs=[], template=false, integration_point=false)\n#         \u2514\u2500\u2500 Text(content=\"Don't forget me this weekend!\")\n</code></pre> <p>Let's discuss about <code>first_child</code>, <code>last_child</code>, <code>parent</code>, <code>next_sibling</code> and <code>prev_sibling</code> properties:</p> <ul> <li> <p>first_child: This property retrieves the first child node of the given element. If the element has no children, it returns <code>None</code>.</p> </li> <li> <p>last_child: This property retrieves the last child node of the given element. If the element has no children, it returns <code>None</code>.</p> </li> <li> <p>parent: This property retrieves the parent node of the given element. If the element has no parent (e.g., it's the root), it returns <code>None</code>.</p> </li> <li> <p>next_sibling: This property retrieves the next sibling node of the given element. If there is no next sibling, it returns <code>None</code>.</p> </li> <li> <p>prev_sibling: This property retrieves the previous sibling node of the given element. If there is no previous sibling, it returns <code>None</code>.</p> </li> </ul> <code>first_child</code><code>last_child</code><code>parent</code><code>next_sibling</code><code>prev_sibling</code> <pre><code>root.first_child\n# Element(name=QualName(local=\"note\"), attrs=[], template=false, integration_point=false)\n\nroot.first_child.first_child\n# Element(name=QualName(local=\"to\"), attrs=[], template=false, integration_point=false)\n</code></pre> <pre><code>root.last_child\n# Element(name=QualName(local=\"note\"), attrs=[], template=false, integration_point=false)\n\nroot.last_child.last_child\n# Element(name=QualName(local=\"body\"), attrs=[], template=false, integration_point=false)\n</code></pre> <pre><code>note_element = root.first_child\n# Element(name=QualName(local=\"note\"), attrs=[], template=false, integration_point=false)\n\nnote_element.parent\n# Document\n\nnote_element.parent == root\n# True\n</code></pre> <pre><code>root.next_sibling\n# None\n\nroot.first_child.next_sibling\n# None\n\nroot.first_child.first_child\n# Element(name=QualName(local=\"body\"), attrs=[], template=false, integration_point=false)\n\nroot.first_child.first_child.next_sibling\n# Text(content=\"\\n        \")\n</code></pre> <pre><code>root.next_sibling\n# None\n\nroot.first_child.prev_sibling\n# None\n\nroot.first_child.last_children\n# Element(name=QualName(local=\"to\"), attrs=[], template=false, integration_point=false)\n\nroot.first_child.first_child.prev_sibling\n# Text(content=\"\\n        \")\n</code></pre> <p>While these properties are useful, they might not always meet our needs. In such cases, methods like <code>.children()</code>, <code>.ancestors()</code>, <code>.prev_siblings()</code>, <code>.next_siblings()</code>, <code>.first_children()</code>, <code>.last_children()</code>, <code>.traverse()</code>, and <code>.descendants()</code> can provide additional functionality.</p> <ul> <li>children() - Returns an iterator which iterates over children of node.</li> <li>ancestors() - Returns an iterator which iterates over ancestors (parents) of node.</li> <li>prev_siblings() - Returns an iterator which iterates over previous siblings of node.</li> <li>next_siblings() - Returns an iterator which iterates over next siblings of node.</li> <li>first_children() - Returns an iterator which iterates over first children.</li> <li>last_children() - Returns an iterator which iterates over last children.</li> <li>traverse() - Returns a traverse iterator.</li> <li>descendants() - Returns an iterator which iterates over a node and its descendants.</li> </ul>"},{"location":"treedom/#build-a-document","title":"Build a document","text":"<p>In MarkupEver, we use a class named <code>TreeDom</code> (1) as a tree structure. This class allows you to work with the document \u2014 move, create, remove, select, serialize, and more. In this tutorial, we'll create a document without using the <code>Parser</code> class. We'll focus on <code>TreeDom</code> properties and methods.</p> <ol> <li>A tree structure which specialy designed for HTML and XML documents. Uses Rust's <code>Vec</code> type in backend.     The memory consumed by the <code>TreeDom</code> is dynamic and depends on the number of tokens stored in the tree.     The allocated memory is never reduced and is only released when it is dropped.</li> </ol>"},{"location":"treedom/#start","title":"Start","text":"<p>To start creating a document, we first need to create a <code>TreeDom</code>.</p> <pre><code>&gt;&gt;&gt; from markupever import dom\n&gt;&gt;&gt; tree = dom.TreeDom()\n</code></pre> <p>Each <code>TreeDom</code> always has a root node of the <code>dom.Document</code> type. We can access it using the <code>.root()</code> method.</p> <pre><code>&gt;&gt;&gt; from markupever import dom\n&gt;&gt;&gt; tree = dom.TreeDom()\n&gt;&gt;&gt; \n&gt;&gt;&gt; root = tree.root() # type is dom.Document\n&gt;&gt;&gt; root\nDocument\n</code></pre> <p>Be Careful</p> <p>Avoid using <code>is</code> for node types in <code>markupever.dom</code> (such as <code>Document</code>, <code>Element</code>, <code>Text</code>, etc.) because they are not alive and serve only as a bridge for you to communicate with the core written in Rust.</p> <pre><code>&gt;&gt;&gt; root = tree.root()\n&gt;&gt;&gt; root is tree.root()\nFalse\n</code></pre>"},{"location":"treedom/#adding-nodes","title":"Adding nodes","text":"<p><code>dom.Document</code> and <code>dom.Element</code> types have methods start with <code>create_</code>. These are help you to create and add new nodes to document. Let's add a DOCTYPE to our document:</p> <pre><code>&gt;&gt;&gt; from markupever import dom\n&gt;&gt;&gt; tree = dom.TreeDom()\n&gt;&gt;&gt;\n&gt;&gt;&gt; tree.root().create_doctype(\"html\")\nDoctype(name=\"html\", public_id=\"\", system_id=\"\")\n</code></pre> <p>Let's check what we did by printing or serializing the tree: <pre><code>&gt;&gt;&gt; print(tree)\nDocument\n\u2514\u2500\u2500 Doctype(name=\"html\", public_id=\"\", system_id=\"\")\n\n&gt;&gt;&gt; tree.serialize(is_html=True)\n'&lt;!DOCTYPE html&gt;'\n</code></pre></p> <p>OK. Let's add some elements and check again: <pre><code>&gt;&gt;&gt; html = tree.root().create_element(\"html\", {\"lang\": \"en\"}) # type is dom.Element\n&gt;&gt;&gt; html.create_element(\"body\")\nElement(name=QualName(local=\"body\", ns=\"\", prefix=None), attrs=[], template=false, integration_point=false)\n\n&gt;&gt;&gt; print(tree)\nDocument\n\u2514\u2500\u2500 Element(name=QualName(local=\"html\", ns=\"\", prefix=None), attrs=[(QualName(local=\"lang\", ns=\"\", prefix=None), \"en\")], template=false, integration_point=false)\n    \u2514\u2500\u2500 Element(name=QualName(local=\"body\", ns=\"\", prefix=None), attrs=[], template=false, integration_point=false)\n\n&gt;&gt;&gt; tree.serialize(is_html=True)\n'&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;'\n</code></pre></p> <p>This is very easy as you can see ...</p>"},{"location":"treedom/#ordering","title":"Ordering","text":"<p>The <code>create_*</code> methods allow you to perform append, prepend, insert after, and insert before operations within the document.</p> <ul> <li>append means adding a child as the last child of a node (default).</li> <li>prepend means adding a child as the first child of a node.</li> <li>insert after means adding a node as the next sibling of another node.</li> <li>insert before means adding a node as the previous sibling of another node.</li> </ul> <p>You can specify the operation with <code>dom.Ordering</code> class and the <code>ordering</code> parameter in the <code>create_*</code> methods.</p> AppendPrependInsert AfterInsert Before <pre><code>from markupever import dom\ntree = dom.TreeDom()\nroot = tree.root()\n\nroot.create_element(\"child1\")\n# document\n# \u2514\u2500\u2500 child1\n\nroot.create_element(\"child2\", ordering=dom.Ordering.APPEND)\n# document\n# \u251c\u2500\u2500 child1\n# \u2514\u2500\u2500 child2\n</code></pre> <pre><code>from markupever import dom\ntree = dom.TreeDom()\nroot = tree.root()\n\nroot.create_element(\"child1\")\n# document\n# \u2514\u2500\u2500 child1\n\nroot.create_element(\"child2\", ordering=dom.Ordering.PREPEND)\n# document\n# \u251c\u2500\u2500 child2\n# \u2514\u2500\u2500 child1\n</code></pre> <pre><code>from markupever import dom\ntree = dom.TreeDom()\nroot = tree.root()\n\nchild = root.create_element(\"child\")\n# document\n# \u2514\u2500\u2500 child\n\nchild.create_element(\"sibling\", ordering=dom.Ordering.AFTER)\n# document\n# \u251c\u2500\u2500 child\n# \u2514\u2500\u2500 sibling\n</code></pre> <pre><code>from markupever import dom\ntree = dom.TreeDom()\nroot = tree.root()\n\nchild = root.create_element(\"child\")\n# document\n# \u2514\u2500\u2500 child\n\nchild.create_element(\"sibling\", ordering=dom.Ordering.BEFORE)\n# document\n# \u251c\u2500\u2500 sibling\n# \u2514\u2500\u2500 child\n</code></pre>"}]}